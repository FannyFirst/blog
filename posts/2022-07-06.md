# Minesweeping in Materialize

Today we are going to write a game!
A massively multiplayer game!

We are going to use Materialize to implement a cooperative version of [Minesweeper](https://en.wikipedia.org/wiki/Minesweeper_(video_game)), inspired by https://m3o.xyz.
We are also going to make what I think is a pretty cool tweak to it, that will allow teams of folks to collaborate in more interesting ways!
But that part comes much later.

Of course, we are also going to show off some of the new and interesting properties of Materialize as we do!

## Minesweeping in General

Minesweeper is a game played on a large grid, in which various mines are concealed under grid squares.
Your job is to discover where the mines are, indirectly.
Rather than click on any mines, instead you are meant to click on non-mine squares, and be told the number of adjacent squares (at most eight) that hide a mine.
Using these numbers and your high-powered noggin you are meant to deduce which squares must have mines, and then which squares cannot have mines, click on them, and repeat indefinitely.


Here's an example visual that we will actually build up to.
Each grid location is a count of the number of adjacent mines, or "`.`" to indicate "unknown".
```
 . . . . . . . . . . . . . . . . . . . . .
 . . . . . . . . . . . . . . . . . . . . .
 . . . . . . . . . . . . . . . . . . . . .
 . . . . . . . . . . . . . . . . . . . . .
 . . . . . . . . . . . . . . . . . . . . .
 . . . . . . . . . . . . . . . . . . . . .
 . . . . . . . . . . . . . . . . . . . . .
 . . . . . . . . . . . . . . . . . . . . .
 . . . . . . . . . 2 1 2 1 3 X . . . . . .
 . . . . . . . . . 1 0 0 0 1 2 X . . . . .
 . . . . . . . . . 1 0 0 0 0 1 1 1 1 . . .
 . . . . . . . . . 1 1 1 1 1 0 0 0 1 . . .
 . . . . . . . . . . . . X 2 1 0 1 1 . . .
 . . . . . X X 2 2 2 . . . X 1 0 1 X . . .
 . . . 2 1 2 2 1 0 1 X 1 1 1 1 0 1 2 . . .
 . . . 2 0 0 0 0 0 1 1 1 0 0 0 0 0 1 . . .
 . . . 2 1 0 0 0 0 0 0 0 0 0 0 0 1 2 . . .
 . . . X 1 1 1 1 0 0 1 1 2 1 1 1 2 X . . .
 . . . . . . X 1 1 1 2 X . . . . . . . . .
 . . . . . . . . . . . . . . . . . . . . .
 . . . . . . . . . . . . . . . . . . . . .
```

Mechanically, you the user "left click" on a square to reveal its count (or explode), and "right click" on a square to flag it as a purported mine.

### Scaling Minesweeping

Minesweeper is normally played on a bounded grid, but there is no reason this needs to be the case.

The rules of Minesweeper make plenty of sense even if the grid cells spill off the side of the window you are looking at.
Moreover, there is no reason you shouldn't be able to scroll around, beyond the limits of the window you might initially open.

There is no reason you shouldn't be able to play minesweeper on a 2^64 x 2^64 game board, where you just happen to pick your favorite coordinate to center your screen on.
We are going to do that.

To make this work, obviously we won't be able to actually populate 2^128 cells.
Instead, we will use a pseudorandom function from `(x, y)` to tell you whether a mine exists at location `(x, y)` or not.
Of course, we will only evaluate the locations around those that a user has clicked on, determining where mines exist lazily but consistently.

### Multiplayer Minesweeper

Why not let multiple folks interact with the Minesweeper board at the same time?

You would need to back it in something like a database, and provide handy views for folks to use.
Fortunately, Materialize is pretty much a databases, so this could plausibly work out.

We'll spend most of the rest of the post doing exactly this, assembling SQL tables, views, and queries to mock up a massively multiplayer minesweeper on Materialize.

### Some deviations

We're going to make a few changes to Minesweeper, in the respective names of ergonomics and fun.

First, clicking on a mine would normally end the game.
It won't do that here.
We'll keep track of the number of mines you've clicked on, and perhaps the leaderboards will reflect area uncovered and mines uncovered, in something of a [Pareto frontier](https://en.wikipedia.org/wiki/Pareto_front).

Second, rather than rolling a die to see *if* a grid cell has a mine for everyone, each grid cell *will* have a mine and we'll roll a die to stamp a number onto the mine.
You can play the game where `0` is what means "mine".
Your friend can play the game where `1` is what means "mine".
Each player plays wearing a certain numbered hat, and observes (and is exploded by) mines of their number.
For any one player, it is as if they are playing Minesweeper with random mine locations.
But if two or more players team up, they can share their information can across the team: locations flagged by players with one number are *safe* for players with another number.

This second change has the cool property that one player racing ahead of others leaves behind breadcrumbs that allow the others to catch up.
If you aren't wild about the change, just get all your friends to pick the same number and you'll see the same mines.

## Minesweeeper in SQL

We are going to start with some module-level documentation describing our plan:
```sql
-- Each (x, y) location has a "mine", a value from 0 through 5.
-- For player `i`, mines with that value are active and may cause them to explode!
-- Each location has only one mine, so one player's discovery unlocks information for others.
```

### Base Tables

We'll model user input as either a guess that a location is a mine ("has the value `foo`") or a guess that a location is mine-free ("does not have the value `foo`").

Let's start with the guesses that a location is a mine (represented in the game as a flag).
We'll add a few helpful views to make sure we don't accidentally treat `flags` as the truth.
```sql
-- Each "flag" is a supposition by `user` that the `mine` value is `flag`.
create table flags (x int, y int, flag int, user text);

-- Protect ourselves against the confusion of multiple entries.
create view distinct_flags as select distinct * from flags;

-- Restrict ourselves to correctly flagged mines.
create view correct_flags as
select x, y, flag, user from distinct_flags
where get_byte(sha256((x::text || y::text)::bytes), 0) % 6 = flag;
```

Here we see the first instance of our function to determine how each grid cell is mined:

```
    get_byte(sha256((x::text || y::text)::bytes), 0) % 6
```

The `x` and `y` coordinates are merged, then hashed, and we pick out one byte to kinda-sorta get a random (if not fair) die roll.
You could certainly change this and get a different game; no strong feelings that this is the correct function.
In particular, the `% 6` is where we determine what fraction of grid cells are mines (one out of six, somewhere between medium and expert difficulties for the Windows version of Minesweeper).

The guesses that a location is *not* a mine are handled similarly, but with an inequality instead:
```sql
-- Each "test" is a supposition that the `mine` value is not `test`.
create table tests (x int, y int, test int, user text);

-- Protect ourselves against the confusion of multiple entries.
create materialized view distinct_tests as select distinct * from tests;

-- Restrict ourselves to correctly tested locations.
create view correct_tests as
select x, y, test, user from distinct_tests
where get_byte(sha256((x::text || y::text)::bytes), 0) % 6 != test;
```

These two tables, `flags` and `tests`, will record the state of the game.
Players play by inserting into these tables using their `user` name.

### Observing some output

If players guess wrong the game still goes on, but let's make some views to notice the errors.
```sql
-- Errors are too bad. But they don't end the game.
create materialized view errors as
select x, y, flag as mine, 'flag' as action, user
from distinct_flags where get_byte(sha256((x::text || y::text)::bytes), 0) % 6 != flag
union all
select x, y, test as mine, 'test' as action, user
from distinct_tests where get_byte(sha256((x::text || y::text)::bytes), 0) % 6 = test;
```

We'll now start up in one session a tailed view of errors:
```
materialize=> copy (tail errors) to stdout;
```
There isn't any output, which makes sense as there also isn't an input.

Let's add an incorrect guess about a mine:
```
materialize=> insert into flags values (0, 0, 0, 'frank');
INSERT 0 1
```
Over in the other session, we get our first line of output:
```
materialize=> copy (tail errors) to stdout;
1657277533154   1       0       0       0       flag    frank
```
This is Materialize's [TAIL](https://materialize.com/docs/sql/tail/) output.
It reports a timestamp, a change in count, and then the columns of the changed row.
In this case, our `flag` guess of `0` at coordinate `(0, 0)` is an error.

Let's introduce the correct guess (on a different player):
```
materialize=> insert into flags values (0, 0, 1, 'arjun');
INSERT 0 1
```
Nothing to report in the other session with the `TAIL`.
This entry wasn't erroneous, and so "no change" in the view.
Had we run the `TAIL` with the `PROGRESS` option, there would be a steady heartbeat of timestamp messages confirming that no changes have occured, which affirmatively distinguishes from the case that the session is just backed up.

### Probing Locations

Our next step is to take our `flag` and `test` collections, and have them prompt reported numbers.
A correct `test` reveals the count under it, as in standard minesweeper.
With our current correct guesses about `(0, 0)`, the probes we should perform are:
```
materialize=> select * from correct_tests;
 x | y | mine | user
---+---+------+------
(0 rows)

materialize=>
```

Ah. Although we know that `(0, 0)` contains a mine of type `1`, we haven't actually tested for `0` yet.
We could do that automatically, but let's ask folks to do this themselves.

```
materialize=> insert into tests values (0, 0, 0, 'frank');
INSERT 0 1
materialize=> select * from correct_tests;
 x | y | mine | user
---+---+------+-------
 0 | 0 |    0 | frank
(1 row)

materialize=>
```

We need to "reach out" from each probe, to assess the mines at each location adjacent to a probe.
When doing this, we keep some notes about where we probed *from* so that we can get the information back efficiently.
Having done this, we aggregate up each probe and have a count to report!

```sql
-- Each tested location invokes a probe at neighbor locations.
create view probes as
select distinct probe_x, probe_y, x, y, user
from
    correct_tests,
    generate_series(x - 1, x + 1) as probe_x,
    generate_series(y - 1, y + 1) as probe_y
where x != probe_x OR y != probe_y;

-- Each location reports some flavor of mine.
create view reports as
select x, y, get_byte(sha256((probe_x::text || probe_y::text)::bytes), 0) % 6 as mine, user
from probes;

-- The number of adjacent mines for probed locations.
create materialized view totals as
select correct_tests.x, correct_tests.y, correct_tests.test as mine, (
    select count(*) from reports
    where correct_tests.x = reports.x
      and correct_tests.y = reports.y
      and correct_tests.test = reports.mine
      and correct_tests.user = reports.user
), user
from correct_tests
group by 1, 2, 3, 5;
```

If we look at the totals for the probes, we see:
```
materialize=> select * from totals;
 x | y | mine | count | user
---+---+------+-------+-------
 0 | 0 |    0 |     0 | frank
(1 row)

materialize=>
```

Luckily mine type `0` has no mines around it, and we should probably click upon all of its neighbors!

Before going down that rabbit hole, let's first figure out how to present this information.

## Presenting Information

We now have all the values for all the probes across a quite large game board.
How do we get that information back to individual players without overwhelming them (or their connection)?

Each player can interrogate the game board with a *viewport*.
This is a description of a rectangular region, all of whose reported counts should be returned.
We also need to include the `mine` and `user`, to know how to present the information, and which subset to present.

```sql
-- Each entry here results in an output viewport (window) for a certain mine.
create table viewport (x1 int, x2 int, y1 int, y2 int, mine int, user text);
```

Each entry in the viewport results in a small grid of locations that we want to report:
```sql
create view cells as
select distinct x, y, mine, user from
    viewport,
    generate_series(x1, x2) as x,
    generate_series(y1, y2) as y
;
```

To get something presentable, we'll fire off some subqueries for each element of `cell`, looking around in other relations that present data.
In particular, we'll first look to see if there is a reported count, then if there is a flagged mine, and finally whether there is a flagged mine of a different type.
```sql
-- Convert counts to symbols, mines, clear cells, and include '.' for unknown locations.
create materialized view composited as
select x, y, mine, user,
    case
        when count is not null then count
        when mined is not null then mined
        when clear is not null then clear
        else ' .'
    end as symbol
from (
    select x, y, mine, user,
        (   -- counts from probes associated with this user.
            select ' '::text || count::text as count
            from totals
            where cells.x = totals.x and cells.y = totals.y and cells.mine = totals.mine and cells.user = totals.user
        ),
        (   -- a red `X` for mines correctly flagged by this user.
            select e'\u001b[31m X\u001b[0m' as mined
            from correct_flags
            where cells.x = correct_flags.x and cells.y = correct_flags.y and cells.mine = correct_flags.flag and cells.user = correct_flags.user
        ),
        (   -- a blue `*` for locations known to be safe by flags of other mines.
            select e'\u001b[34m *\u001b[0m' as clear
            from correct_flags
            where cells.x = correct_flags.x and cells.y = correct_flags.y and not cells.mine = correct_flags.flag
        )
    from cells
);

-- Create lines of output by grouping by `y`.
create view output as
select y, mine, string_agg(symbol, '' ORDER BY x) AS whole_row, user
from composited
group by y, mine, user;
```

To view the output, we'll need to introduce some viewports, specifying rectangle and mine type:

```sql
-- Define some overlapping viewports.
insert into viewport values (-10, 10, -10, 10, 0, 'frank');
insert into viewport values (-5, 10, -5, 5, 1, 'arjun');
```

We can now peek at the output by selecting `whole_row` and ordering by `y`.
Let's first look at the `0` mine:

```
materialize=> select whole_row from output where mine = 0 and user = 'frank' order by y;
                 whole_row
--------------------------------------------
  . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . 0 . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . .
(21 rows)

materialize=>
```

Fascinating!

Let's do the `1` mine next:
```
materialize=> select whole_row from output where mine = 1 and user = 'arjun' order by y;
            whole_row
----------------------------------
  . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . .
  . . . . . X . . . . . . . . . .
  . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . .
(11 rows)

materialize=>
```

Equally fascinating!
The same location, with different takes for different players, is visible on both outputs!

Let's now ramp up the amount of visible information by making some informed guesses.

## Using SQL to play Minesweeper

You play Minesweeper by repeatedly `INSERT`ing into `flags` and `tests`.
This probably gets tedious very quickly.
I couldn't tell you; I haven't tried.

Instead, we can write SQL queries to produce modifications to these tables.

### Determining locations to test

We should be able to test any location that has no adjacent mines (of our type).
This is just a matter of looking at `totals` for counts of zero, and testing all neighbors.

```sql
-- We can test locations we know have no adjacent mines!
-- In fact, we can do this over and over until we stop inserting things.
create materialized view should_test as
select distinct new_x as x, new_y as y, mine as test, user
from
    (select * from totals where count = 0),
    generate_series(x - 1, x + 1) as new_x,
    generate_series(y - 1, y + 1) as new_y
where x != new_x or y != new_y
except all
select * from distinct_tests;
```

If we peek at the contents of this view, we'll see locations that are safe to test.
```
materialize=> select * from should_test;
 x  | y  | test | user
----+----+------+-------
  0 |  1 |    0 | frank
  0 | -1 |    0 | frank
  1 |  0 |    0 | frank
  1 |  1 |    0 | frank
  1 | -1 |    0 | frank
 -1 |  0 |    0 | frank
 -1 |  1 |    0 | frank
 -1 | -1 |    0 | frank
(8 rows)

materialize=>
```
As it turns out, all eight locations around the `(0, 0)` location are safe to test for mines of type `0`.
We could go and `INSERT` each of them, or we could use a SQL query to do that for us:

```
materialize=> insert into tests select * from should_test;
INSERT 0 8
```

This is now an exciting moment.
Let's look at the board again, for mines of type `0`.
```
materialize=> select whole_row from output where mine = 0 and user = 'frank' order by y;
                 whole_row
-----------------------
  . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . 1 0 0 . . . . . . . . .
  . . . . . . . . . 1 0 0 . . . . . . . . .
  . . . . . . . . . 1 1 1 . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . .
(21 rows)

materialize=>
```

We have more zeros!
You Minesweeper folks know what this means!
We .. should keep clicking.
We shouldn't *have* to keep clicking, but Materialize doesn't support `WITH RECURSIVE` yet (write your representative!)

```
materialize=> insert into tests select * from should_test;
INSERT 0 8
materialize=>
```

Eight more insertions!
This means that things changed again.

```
materialize=> select whole_row from output where mine = 0 and user = 'frank' order by y;
                 whole_row
-----------------------
  . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . 2 1 2 1 . . . . . . . .
  . . . . . . . . . 1 0 0 0 . . . . . . . .
  . . . . . . . . . 1 0 0 0 . . . . . . . .
  . . . . . . . . . 1 1 1 1 . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . .
(21 rows)

materialize=>
```

Let's do a hand-rolled recursive process, and keep doing this `INSERT INTO` command until we have no more changes.
```
materialize=> insert into tests select * from should_test;
INSERT 0 4
materialize=> insert into tests select * from should_test;
INSERT 0 3
materialize=> insert into tests select * from should_test;
INSERT 0 5
materialize=> insert into tests select * from should_test;
INSERT 0 6
materialize=> insert into tests select * from should_test;
INSERT 0 6
materialize=> insert into tests select * from should_test;
INSERT 0 3
materialize=> insert into tests select * from should_test;
INSERT 0 9
materialize=> insert into tests select * from should_test;
INSERT 0 8
materialize=> insert into tests select * from should_test;
INSERT 0 4
materialize=> insert into tests select * from should_test;
INSERT 0 3
materialize=> insert into tests select * from should_test;
INSERT 0 3
materialize=> insert into tests select * from should_test;
INSERT 0 6
materialize=> insert into tests select * from should_test;
INSERT 0 7
materialize=> insert into tests select * from should_test;
INSERT 0 7
materialize=> insert into tests select * from should_test;
INSERT 0 4
materialize=> insert into tests select * from should_test;
INSERT 0 4
materialize=> insert into tests select * from should_test;
INSERT 0 3
materialize=> insert into tests select * from should_test;
INSERT 0 0
materialize=>
```

You can imagine why `WITH RECURSIVE` can occasionally be popular.

Let's take a peek at the output again.
```
materialize=> select whole_row from output where mine = 0 and user = 'frank' order by y;
                 whole_row
-----------------------
  . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . 2 1 2 1 3 . . . . . . .
  . . . . . . . . . 1 0 0 0 1 2 . . . . . .
  . . . . . . . . . 1 0 0 0 0 1 1 1 1 . . .
  . . . . . . . . . 1 1 1 1 1 0 0 0 1 . . .
  . . . . . . . . . . . . . 2 1 0 1 1 . . .
  . . . . . . . 2 2 2 . . . . 1 0 1 . . . .
  . . . 2 1 2 2 1 0 1 . 1 1 1 1 0 1 2 . . .
  . . . 2 0 0 0 0 0 1 1 1 0 0 0 0 0 1 . . .
  . . . 2 1 0 0 0 0 0 0 0 0 0 0 0 1 2 . . .
  . . . . 1 1 1 1 0 0 1 1 2 1 1 1 2 . . . .
  . . . . . . . 1 1 1 2 . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . .
(21 rows)

materialize=>
```

That's pretty neat, isn't it!
We've built up a little island, and might now start thinking about where we can certainly place mines.

### Determining locations to flag

We can place flags using a variety of rules.
We'll use a simple one: if a grid cell with a count is short mines exactly the number of unmarked neighbors, all those neighbors must be mines.
This rule is great for filling in all of those nooks and crannies you see up above.

```sql
-- We can flag locations when the count equals the number of untested neighbors.
create materialized view should_flag_from as
select x, y, mine as flag, user
from totals
where totals.count > 0 and totals.count = 9 - (select count(*) from (
    select distinct *
    from
        generate_series(x - 1, x + 1) as probe_x,
        generate_series(y - 1, y + 1) as probe_y,
        correct_tests as tests
    where tests.x = probe_x and tests.y = probe_y and tests.test = mine
));

-- All adjacent, unmarked locations must be mines.
create view should_flag as
select distinct * from (select probe_x as x, probe_y as y, flag, user
from
    should_flag_from,
    generate_series(x - 1, x + 1) as probe_x,
    generate_series(y - 1, y + 1) as probe_y
)
except all
select * from correct_tests
except all
select * from distinct_flags;
```

We can take a peek at the `should_flag` view, containing locations known to be mines.

```
materialize=> select * from should_flag;
 x  | y  | flag | user
----+----+------+-------
  0 |  4 |    0 | frank
  1 |  8 |    0 | frank
  2 |  2 |    0 | frank
  3 |  3 |    0 | frank
  4 | -2 |    0 | frank
  5 | -1 |    0 | frank
  7 |  3 |    0 | frank
  7 |  7 |    0 | frank
 -7 |  7 |    0 | frank
 -5 |  3 |    0 | frank
 -4 |  3 |    0 | frank
 -4 |  8 |    0 | frank
(12 rows)

materialize=>
```

Let's just add them in, and check out the picture again.

```
materialize=> insert into flags select * from should_flag;
INSERT 0 12
materialize=> select whole_row from output where mine = 0 and user = 'frank' order by y;
                 whole_row
-----------------------
  . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . 2 1 2 1 3 X . . . . . .
  . . . . . . . . . 1 0 0 0 1 2 X . . . . .
  . . . . . . . . . 1 0 0 0 0 1 1 1 1 . . .
  . . . . . . . . . 1 1 1 1 1 0 0 0 1 . . .
  . . . . . . . . . . . . X 2 1 0 1 1 . . .
  . . . . . X X 2 2 2 . . . X 1 0 1 X . . .
  . . . 2 1 2 2 1 0 1 X 1 1 1 1 0 1 2 . . .
  . . . 2 0 0 0 0 0 1 1 1 0 0 0 0 0 1 . . .
  . . . 2 1 0 0 0 0 0 0 0 0 0 0 0 1 2 . . .
  . . . X 1 1 1 1 0 0 1 1 2 1 1 1 2 X . . .
  . . . . . . X 1 1 1 2 X . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . .
(21 rows)

materialize=>
```

Look at all those `X` things!

### Ready Player `arjun`

Having marked all these mines of type `0`, the boards for other mine types can be updated!
Remember, each of these mines mean that the grid cell is free of mines of other types.
If we peek, we'll see blue asterisks indicating where mines have been flagged by others.
```
materialize=> select whole_row from output where mine = 1 and user = 'arjun' order by y;
 . . . . . . . . . . . . . . . .
 . . . . . . . . . . . . . . . .
 . . . . . . . . . . . . . . . .
 . . . . . . . . . * . . . . . .
 . . . . . . . . . . * . . . . .
 . . . . . X . . . . . . . . . .
 . . . . . . . . . . . . . . . .
 . . . . . . . * . . . . . . . .
 * * . . . . . . * . . . * . . .
 . . . . . * . . . . . . . . . .
 . . . . . . . . . . . . . . . .
materialize=>
```

Fortunately, `arjun` can see them as blue
Let's add all of our correct mine placement to `tests` for another user.
```
materialize=> insert into tests select x, y, 1, 'arjun' from correct_flags where not flag = 1;
INSERT 0 12
materialize=> select whole_row from output where mine = 1 and user = 'arjun' order by y;
            whole_row
----------------------------------
  . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . .
  . . . . . . . . . 3 . . . . . .
  . . . . . . . . . . 1 . . . . .
  . . . . . X . . . . . . . . . .
  . . . . . . . . . . . . . . . .
  . . . . . . . 2 . . . . . . . .
  1 1 . . . . . . 1 . . . 2 . . .
  . . . . . 1 . . . . . . . . . .
  . . . . . . . . . . . . . . . .
(11 rows)

materialize=>
```

Interesting!
We still see that mine there, but now have several other locations that have been explored.
No zeros though, so no automatic progress to make.

How about mines of type `2`?

```
materialize=> insert into tests select x, y, 2, 'brent' from correct_flags where not flag = 2;
INSERT 0 13
materialize=> materialize=> insert into viewport values (-10, 10, -10, 10, 2, 'brent');
INSERT 0 1
materialize=> select whole_row from output where mine = 2 and user = 'brent' order by y;
                 whole_row
--------------------------------------------
  . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . 0 . . . . . .
  . . . . . . . . . . . . . . . 4 . . . . .
  . . . . . . . . . . 4 . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . 0 . . . . . . . .
  . . . . . 2 6 . . . . . . 6 . . . 6 . . .
  . . . . . . . . . . 4 . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . .
  . . . 0 . . . . . . . . . . . . . 0 . . .
  . . . . . . 2 . . . . 2 . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . .
(21 rows)

materialize=>
```

This player now has some zeros to explore, beyond the four at `(0, 0)`.
```
materialize=> insert into tests select * from should_test;
INSERT 0 30
materialize=> insert into tests select * from should_test;
INSERT 0 19
materialize=> insert into tests select * from should_test;
INSERT 0 15
materialize=> insert into tests select * from should_test;
INSERT 0 21
materialize=> insert into tests select * from should_test;
INSERT 0 16
materialize=> insert into tests select * from should_test;
INSERT 0 21
materialize=> insert into tests select * from should_test;
INSERT 0 25
materialize=> insert into tests select * from should_test;
INSERT 0 29
materialize=> insert into tests select * from should_test;
INSERT 0 12
materialize=> insert into tests select * from should_test;
INSERT 0 9
materialize=> insert into tests select * from should_test;
INSERT 0 8
materialize=> insert into tests select * from should_test;
INSERT 0 2
materialize=> insert into tests select * from should_test;
INSERT 0 0
```

```
materialize=> select whole_row from output where mine = 2 and user = 'brent' order by y;
                 whole_row
--------------------------------------------
  . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . 1 1 1 2 . . . . .
  . . . . . 2 2 1 1 1 . . 1 0 0 1 . . . . .
  . 1 1 2 2 1 0 0 0 1 . . 2 1 2 2 . . . . .
  1 1 0 0 0 0 1 1 1 1 2 . . . . . . . . 1 1
  1 0 0 0 0 1 2 . 1 0 1 1 2 1 . . . . . 1 0
  1 0 0 0 0 1 . . 2 0 0 0 0 1 . . . . . 2 1
  1 0 0 0 0 1 3 . 4 2 1 1 2 3 . . . 3 . . 1
  1 0 1 1 1 1 . . . . 2 . . . . . . . . 2 1
  1 0 1 . . . . . . . . . . . . . 1 1 1 1 0
  1 0 1 1 1 1 3 . . . . . . . . . 2 0 0 0 0
  0 0 0 0 0 0 2 . . . . . . . . . 2 0 0 0 0
  0 1 1 2 1 1 1 . . . . 1 . . . . 4 1 2 1 1
  0 1 . . . . . . . . . . . . . . . . . . .
  0 1 1 2 1 2 . . . . . . . . . . . . . . .
(21 rows)

materialize=>
```

The expanded regions spill off the viewport in a few directions!

## Going interactive

Everything we've done so far has been vanilla SQL.
While Materialize does this well, and scales out, we haven't used its super power yet.

Let's do that now by making each viewport continually update in response to changes made by *others*.

```
materialize=> copy (tail (select y, whole_row from output where mine = 0 and user = 'frank')) to stdout;
1660070908901	1	0	 . . . . . . . . . 1 0 0 0 0 1 1 1 1 . . .
1660070908901	1	1	 . . . . . . . . . 1 1 1 1 1 0 0 0 1 . . .
1660070908901	1	5	 . . . 2 0 0 0 0 0 1 1 1 0 0 0 0 0 1 . . .
1660070908901	1	6	 . . . 2 1 0 0 0 0 0 0 0 0 0 0 0 1 2 . . .
1660070908901	1	9	 . . . . . . . . . . . . . . . . . . . . .
1660070908901	1	10	 . . . . . . . . . . . . . . . . . . . . .
1660070908901	1	-10	 . . . . . . . . . . . . . . . . . . . . .
1660070908901	1	-9	 . . . . . . . . . . . . . . . . . . . . .
1660070908901	1	-8	 . . . . . . . . . . . . . . . . . . . . .
1660070908901	1	-7	 . . . . . . . . . . . . . . . . . . . . .
1660070908901	1	-6	 . . . . . . . . . . . . . . . . . . . . .
1660070908901	1	-5	 . . . . . . . . . . . . . . . . . . . . .
1660070908901	1	-4	 . . . . . . . . . . . . . . . . . . . . .
1660070908901	1	-3	 . . . . . . . . . . . . . . . . . . . . .
1660070908901	1	2	 . . . . . . . . . . . . X 2 1 0 1 1 . . .
1660070908901	1	4	 . . . 2 1 2 2 1 0 1 X 1 1 1 1 0 1 2 . . .
1660070908901	1	-2	 . . . . . . . . . 2 1 2 1 3 X . . . . . .
1660070908901	1	-1	 . . . . . . . . . 1 0 0 0 1 2 X . . . . .
1660070908901	1	7	 . . . X 1 1 1 1 0 0 1 1 2 1 1 1 2 X . . .
1660070908901	1	8	 . . . . . . X 1 1 1 2 X . . . . . . . . .
1660070908901	1	3	 . . . . . X X 2 2 2 . . . X 1 0 1 X . . .
```

Well, we've lost some of the visual flair, unfortunately.
You will have to imagine this being elegantly presented to users, as this is not something `psql` was designed for.

However, if we crack open a different terminal, we can `TAIL` each of the other players.
```
materialize=> copy (tail (select y, whole_row from output where mine = 1 and user = 'arjun')) to stdout;
1660071032901	1	1	 . . . . . . . . . . . . . . . .
1660071032901	1	2	 . . . . . . . 2 . . . . . . . .
1660071032901	1	3	 1 1 . . . . . . 1 . . . 2 . . .
1660071032901	1	4	 . . . . . 1 . . . . . . . . . .
1660071032901	1	5	 . . . . . . . . . . . . . . . .
1660071032901	1	-5	 . . . . . . . . . . . . . . . .
1660071032901	1	-4	 . . . . . . . . . . . . . . . .
1660071032901	1	-3	 . . . . . . . . . . . . . . . .
1660071032901	1	-2	 . . . . . . . . . 3 . . . . . .
1660071032901	1	-1	 . . . . . . . . . . 1 . . . . .
1660071032901	1	0	 . . . . . X . . . . . . . . . .
```
and
```
materialize=> copy (tail (select y, whole_row from output where mine = 2 and user = 'brent')) to stdout;
1660071083901	1	0	 1 1 0 0 0 0 1 1 1 1 2 . . . . . . . . 1 1
1660071083901	1	1	 1 0 0 0 0 1 2 . 1 0 1 1 2 1 . . . . . 1 0
1660071083901	1	2	 1 0 0 0 0 1 . . 2 0 0 0 0 1 . . . . . 2 1
1660071083901	1	3	 1 0 0 0 0 1 3 . 4 2 1 1 2 3 . . . 3 . . 1
1660071083901	1	4	 1 0 1 1 1 1 . . . . 2 . . . . . . . . 2 1
1660071083901	1	5	 1 0 1 . . . . . . . . . . . . . 1 1 1 1 0
1660071083901	1	6	 1 0 1 1 1 1 3 . . . . . . . . . 2 0 0 0 0
1660071083901	1	7	 0 0 0 0 0 0 2 . . . . . . . . . 2 0 0 0 0
1660071083901	1	8	 0 1 1 2 1 1 1 . . . . 1 . . . . 4 1 2 1 1
1660071083901	1	9	 0 1 . . . . . . . . . . . . . . . . . . .
1660071083901	1	10	 0 1 1 2 1 2 . . . . . . . . . . . . . . .
1660071083901	1	-10	 . . . . . . . . . . . . . . . . . . . . .
1660071083901	1	-9	 . . . . . . . . . . . . . . . . . . . . .
1660071083901	1	-8	 . . . . . . . . . . . . . . . . . . . . .
1660071083901	1	-7	 . . . . . . . . . . . . . . . . . . . . .
1660071083901	1	-6	 . . . . . . . . . . . . . . . . . . . . .
1660071083901	1	-5	 . . . . . . . . . . . . . . . . . . . . .
1660071083901	1	-4	 . . . . . . . . . . . . . . . . . . . . .
1660071083901	1	-3	 . . . . . . . . . . . . 1 1 1 2 . . . . .
1660071083901	1	-2	 . . . . . 2 2 1 1 1 . . 1 0 0 1 . . . . .
1660071083901	1	-1	 . 1 1 2 2 1 0 0 0 1 . . 2 1 2 2 . . . . .
```

### Playing the game

At this point, `brent` has a bunch of `X` marks to place.
Let's do that.

We got some immediate and new output for each of our players.
Respectively,
```
1660071152677	-1	1	 . . . . . . . . . 1 1 1 1 1 0 0 0 1 . . .
1660071152677	-1	9	 . . . . . . . . . . . . . . . . . . . . .
1660071152677	-1	10	 . . . . . . . . . . . . . . . . . . . . .
1660071152677	1	1	 . . . . . . . * . 1 1 1 1 1 0 0 0 1 . . .
1660071152677	-1	2	 . . . . . . . . . . . . X 2 1 0 1 1 . . .
1660071152677	-1	4	 . . . 2 1 2 2 1 0 1 X 1 1 1 1 0 1 2 . . .
1660071152677	1	9	 . . * . . . . . . . . . . . . . . . . . .
1660071152677	1	10	 . . . . . . * . . . . . . . . . . . . . .
1660071152677	-1	-2	 . . . . . . . . . 2 1 2 1 3 X . . . . . .
1660071152677	-1	-1	 . . . . . . . . . 1 0 0 0 1 2 X . . . . .
1660071152677	1	2	 . . . . . . * . . . . . X 2 1 0 1 1 . . .
1660071152677	1	4	 . . . 2 1 2 2 1 0 1 X 1 1 1 1 0 1 2 * . .
1660071152677	1	-1	 * . . . . . . . . 1 0 0 0 1 2 X . . . . .
1660071152677	1	-2	 . . . * * . . . . 2 1 2 1 3 X . . . . . .
1660071152677	-1	3	 . . . . . X X 2 2 2 . . . X 1 0 1 X . . .
1660071152677	1	3	 . . . . . X X 2 2 2 . . . X 1 0 1 X . * .
```
and
```
1660071152677	-1	1	 . . . . . . . . . . . . . . . .
1660071152677	-1	2	 . . . . . . . 2 . . . . . . . .
1660071152677	-1	3	 1 1 . . . . . . 1 . . . 2 . . .
1660071152677	-1	4	 . . . . . 1 . . . . . . . . . .
1660071152677	-1	-1	 . . . . . . . . . . 1 . . . . .
1660071152677	-1	0	 . . . . . X . . . . . . . . . .
1660071152677	1	1	 . . * . . . . . . . . . . . . .
1660071152677	1	2	 . * . . . . . 2 . . . . . . . .
1660071152677	1	3	 1 1 . . . . . . 1 . . . 2 . * .
1660071152677	1	-1	 . . . . . * . . . . 1 . . . . .
1660071152677	1	0	 . . . . . X * . . . . . . . . .
1660071152677	1	4	 . . . * * 1 . . . . . . . * . .
```
and
```
1660071152677	-1	0	 1 1 0 0 0 0 1 1 1 1 2 . . . . . . . . 1 1
1660071152677	-1	1	 1 0 0 0 0 1 2 . 1 0 1 1 2 1 . . . . . 1 0
1660071152677	-1	2	 1 0 0 0 0 1 . . 2 0 0 0 0 1 . . . . . 2 1
1660071152677	-1	3	 1 0 0 0 0 1 3 . 4 2 1 1 2 3 . . . 3 . . 1
1660071152677	-1	4	 1 0 1 1 1 1 . . . . 2 . . . . . . . . 2 1
1660071152677	-1	5	 1 0 1 . . . . . . . . . . . . . 1 1 1 1 0
1660071152677	-1	9	 0 1 . . . . . . . . . . . . . . . . . . .
1660071152677	-1	10	 0 1 1 2 1 2 . . . . . . . . . . . . . . .
1660071152677	-1	-2	 . . . . . 2 2 1 1 1 . . 1 0 0 1 . . . . .
1660071152677	-1	-1	 . 1 1 2 2 1 0 0 0 1 . . 2 1 2 2 . . . . .
1660071152677	1	0	 1 1 0 0 0 0 1 1 1 1 2 X . . . . . . . 1 1
1660071152677	1	1	 1 0 0 0 0 1 2 X 1 0 1 1 2 1 . . . . . 1 0
1660071152677	1	2	 1 0 0 0 0 1 X . 2 0 0 0 0 1 . . . . . 2 1
1660071152677	1	3	 1 0 0 0 0 1 3 . 4 2 1 1 2 3 . . . 3 . X 1
1660071152677	1	5	 1 0 1 X . . . . . . . . . . . . 1 1 1 1 0
1660071152677	1	9	 0 1 X . . . . . . . . . . . . . . . . . .
1660071152677	1	10	 0 1 1 2 1 2 X . . . . . . . . . . . . . .
1660071152677	1	-2	 . . . X X 2 2 1 1 1 . . 1 0 0 1 . . . . .
1660071152677	1	-1	 X 1 1 2 2 1 0 0 0 1 X . 2 1 2 2 . . . . .
1660071152677	1	4	 1 0 1 1 1 1 . . X X 2 . . . . . . . X 2 1
```

That's all a bit of a mess.
If you look hard you'll notice that lines are changing for the first two players through the addition of `*` symbols.
For the third player, it is the addition of `X` symbols.

This becomes much clearer if we were to `TAIL` the `composited` materialized view.
That is the view with the `(x, y, symbol)` columns, before we format it in to lines.
It ends up much leaner, indicating only the exact `(x, y)` locations that have changed, and from which symbol to which.

### Reshaphing the viewports

Let's say `brent` wants to move his viewport around, as he has things to click that are offscreen.
This is an `UPDATE` in SQL, which we could write as
```sql
materialize=> update viewport set y1 = -15, y2 = 10 where user = 'brent';
UPDATE 1
```
This results in five new rows at what would be the bottom of `brent`'s screen.
```
1660071720485	1	11	 0 0 0 0 0 1 2 . . . . . . . . . . . . . .
1660071720485	1	12	 0 0 0 0 0 0 1 . . . . . . . . . . . . . .
1660071720485	1	13	 2 1 1 1 1 0 1 . . . . . . . . . . . . . .
1660071720485	1	15	 . . . . . . . . . . . . . . . . . . . . .
1660071720485	1	14	 . . . X 2 1 2 . . . . . . . . . . . . . .
```

Although it is hard to demonstrate with whole lines at a time, if you tail `composited` then horizontal scrolling is lean as well.
You only receive the new information you require: whole rows and columns, rather than all of the central data you already know.

## Winding down

There is a lot of neat stuff going on here that I didn't talk about.

I didn't explain why I put `materialized` in some `create view` statements and not in others.
There is a good reason, based on sharing that data out to multiple players to avoid re-doing work.

We didn't scale this up at all.
We could have!
We'll do that in the future, once there is a better UI in place.

We didn't show off several of Materialize's other neat super-powers.
We didn't spin up new clusters to house materialized views for each player.
We didn't transparently rescale clusters housing the main game materialized views.
We didn't show off the strong consistency properties as two players make concurrent updates.

We'll try and get back to these, but we'll also spill out posts about each of these cool properties in the months to come.