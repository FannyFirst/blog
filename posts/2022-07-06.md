# Minesweeping in Materialize

Today we are going to write a game!
A massively multiplayer game!

We are going to use Materialize to implement a cooperative version of [Minesweeper](https://en.wikipedia.org/wiki/Minesweeper_(video_game)), inspired by https://m3o.xyz.
We are also going to make what I think is a pretty cool tweak to it, that will allow teams of folks to collaborate more effectively.

Of course, we are also going to show off some of the new and interesting properties of Materialize as we do!

## Minesweeping in General

Minesweeper is a game played on a large grid, in which various mines are concealed under grid squares.
Your job is to discover where the mines are, indirectly.
Rather than click on any mines, instead you are meant to click on non-mine squares, and be told the number of adjacent squares (at most eight) that hide a mine.
Using these numbers and your high-powered noggin you are meant to deduce which squares must have mines, and then which squares cannot have mines, click on them, and repeat indefinitely.

Mechanically, you can "left click" on a square to reveal its count (or explode), and you can "right click" on a square to flag it as a purported mine.

### Scaling Minesweeping

Minesweeper is normally played on a bounded grid, but there is no reason this needs to be the case.

The rules of Minesweeper make plenty of sense even if the grid cells spill off the side of the window you are looking at.
There is no reason you shouldn't be able to scroll around, beyond the limits of the window you might initially open.

There is no reason you shouldn't be able to play minesweeper on a 2^64 x 2^64 game board, where you just happen to pick your favorite coordinate to center your screen on.

To make this work, obviously you won't be able to actually populate 2^128 cells with mines or not.
Instead, you can use a pseudorandom function from (x, y) to tell you whether a mine exists or not.
Of course, you only evaluate the locations around those that a user has clicked on, determining where mines exist lazily but consistently.

### Multiplayer Minesweeper

Why not let multiple folks interact with the Minesweeper board at the same time?

You would need to back it in something like a database, and provide handy views for folks to use.
Fortunately, Materialize is pretty much a databases, so this could plausibly work out.

We'll spend most of the rest of the post doing exactly this, assembling SQL tables, views, and queries to mock up a massively multiplayer minesweeper on Materialize.

### Some deviations

We're going to make a few changes to Minesweeper, in the respective names of ergonomics and fun.

First, clicking on a mine would normally end the game.
It won't do that here.
We'll keep track of the number of mines you've clicked on, and perhaps the leaderboards will reflect area uncovered and mines uncovered, in something of a [Pareto frontier](https://en.wikipedia.org/wiki/Pareto_front).

Second, rather than rolling a die to see if a grid cell has a mine for everyone, each grid cell *will* have a mine and we'll roll a die to stamp a number onto the mine.
Each player plays wearing a certain numbered hat, and observes (and is exploded by) mines of their number.
For any one player, it is as if they are playing Minesweeper with random mine locations.
For any two players, each appear to be playing Minesweeper with random mine locations.
But if two or more players team up, their information can leak across the team: locations flagged by players with one number are *safe* for players with another number.

This second change has the cool property that one player racing ahead of others leaves behind breadcrumbs that allow the others to catch up.
If you aren't wild about the change, just get all your friends to pick the same number and you'll see the same mines.

## Minesweeeper in SQL

We are going to start with some module-level documentation describing our plan:
```sql
-- Each (x, y) location has a "mine", a value from 0 through 5.
-- For player `i`, mines with that value are active and may cause them to explode!
-- Each location has only one mine, so one player's discovery unlocks information for others.
```

### Base Tables

We'll model user input as either a guess that a location is a mine (so, "has the value `foo`") or a guess that a location is mine-free (so, "does not have the value `foo`).

Let's start with the guesses that a location is a mine (represented in the game as a flag).
We'll add a few helpful views to make sure we don't accidentally treat `flags` as the truth.
```sql
-- Each "flag" is a supposition that the `mine` value is `flag`.
create table flags (x int, y int, flag int);
create view distinct_flags as select distinct * from flags;
create view correct_flags as
select x, y, flag from distinct_flags
where get_byte(sha256((x::text || y::text)::bytes), 0) % 6 = flag;
```

Here we see the first instance of our function to determine how each grid cell is mined:

```
    get_byte(sha256((x::text || y::text)::bytes), 0) % 6
```

The `x` and `y` coordinates are merged, then hashed, and we pick out one byte to kinda-sorta get a random (if not fair) die roll.
You could certainly change this and get a different game; no strong feelings that this is the correct function.
In particular, the `% 6` is where we determine what fraction of grid cells are mines (one out of six, somewhere between medium and expert difficulties for the Windows version of Minesweeper).

The guesses that a location is *not* a mine are handled similarly, but with an inequality instead:
```sql
-- Each "test" is a supposition that the `mine` value is not `test`.
create table tests (x int, y int, test int);
create view distinct_tests as select distinct * from tests;
create view correct_tests as
select x, y, test from distinct_tests
where get_byte(sha256((x::text || y::text)::bytes), 0) % 6 != test;
```

These two tables will record the state of the game.
Players can play by inserting into these tables.
If they guess wrong the game still goes on, but we'll make some views to notice the errors.
```sql
-- Errors are too bad. But they don't end the game.
create view errors as
select x, y, flag as mine, 'flag' as action
from distinct_flags where get_byte(sha256((x::text || y::text)::bytes), 0) % 6 != flag
union all
select x, y, test as mine, 'test' as action
from distinct_tests where get_byte(sha256((x::text || y::text)::bytes), 0) % 6 = test;
```

We'll now start up in one session a tailed view of errors:
```
materialize=> copy (tail errors) to stdout;
```
There isn't any output, which makes sense as there also isn't an input.

Let's add an incorrect guess about a mine:
```
materialize=> insert into flags values (0, 0, 0);
INSERT 0 1
```
Over in the other session, we get our first line of output:
```
materialize=> copy (tail errors) to stdout;
1657222287227   1       0       0       0       flag
```
This is Materialize's [TAIL](https://materialize.com/docs/sql/tail/) output.
It reports a timestamp, a change in count, and then the columns of the changed row.
In this case, our `flag` guess of `0` at coordinate `(0, 0)` is an error.

Let's introduce the correct guess:
```
materialize=> insert into flags values (0, 0, 1);
INSERT 0 1
```
Nothing to report in the other session with the `TAIL`.
This entry wasn't erroneous, and so "no change" in the view.
Had we run the `TAIL` with the `PROGRESS` option, there would be a steady heartbeat of timestamp messages confirming that no changes have occured, not just that the session is backed up.

### Probing Locations

Our next step is to take our `flag` and `test` collections, and have them prompt reported numbers.
A correct `test` reveals the count under it, as in standard minesweeper.
Additionally, a correct `flag` reveals the counts for all other players.
We'll call that collection of location and player `probes`.

```sql
-- Each correct flag and test result in probes that are conducted and reported.
--   A correct flag results in a probe and report for *each other* values.
--   A correct test results in a probe and report for *that one* value.
create view probes as
select x, y, test as mine
from correct_tests
union all
select x, y, mine
from correct_flags, generate_series(0, 5) as mine
where mine != flag;
```

With our current correct guess about `(0, 0)`, the probes we should perform are:
```
materialize=> select * from probes;
 x | y | mine
---+---+------
 0 | 0 |    0
 0 | 0 |    2
 0 | 0 |    3
 0 | 0 |    4
 0 | 0 |    5
(5 rows)
```
Each of the mine types other than `1` should be probed, as we have evidence that they are not mines.

We need to "reach out" from each probe, to assess the mines at each location adjacent to a probe.
When doing this, we keep some notes about where we probed *from* so that we can get the information back efficiently.
Having done this, we aggregate up each probe and have a count to report!

```sql
-- Each tested location invokes a probe at neighbor locations.
create view probe_neighbors as
select distinct probe_x, probe_y, x, y
from
    probes,
    generate_series(x - 1, x + 1) as probe_x,
    generate_series(y - 1, y + 1) as probe_y
where x != probe_x OR y != probe_y;

-- Each location reports some flavor of mine.
create view reports as
select x, y, get_byte(sha256((probe_x::text || probe_y::text)::bytes), 0) % 6 as mine
from probe_neighbors;

-- The number of adjacent mines for probed locations.
create view totals as
select probes.x, probes.y, probes.mine, (
    select count(*) from reports
    where probes.x = reports.x and probes.y = reports.y and probes.mine = reports.mine
)
from probes
group by 1, 2, 3;
```

If we look at the totals for the probes, we see:
```
materialize=> select * from totals;
 x | y | mine | count
---+---+------+-------
 0 | 0 |    0 |     0
 0 | 0 |    2 |     2
 0 | 0 |    3 |     1
 0 | 0 |    4 |     1
 0 | 0 |    5 |     2
(5 rows)

materialize=>
```

Lucky mine type `0` has no mines around it, and should probably be clicked upon!
Each of the other mine types have some non-zero counts, and we should present that slightly better than this table.

## Presenting Information

We now have all the values for all the probes across a quite large game board.
How do we get that information back to individual players without overwhelming them (or their connection)?

Each player can interrogate the game board with a *viewport*.
This is a description of a rectangular region, all of whose reported counts should be returned.

```sql
-- Each entry here results in an output viewport (window) for a certain mine.
create table viewport (x1 int, x2 int, y1 int, y2 int, mine int);
```

Each entry in the viewport results in a small grid of locations that we want to report:
```sql
create view cells as
select distinct x, y, mine from
    viewport,
    generate_series(x1, x2) as x,
    generate_series(y1, y2) as y
;
```

To actually get something presentable we'll convert all counts to symbols, and then left join with `cells` to be sure we can present *something* (a `.`) for locations without a count.
```sql
-- Convert counts to symbols, and include '.' for empty locations.
create view symbols as
select x, y, mine, case when symbol isnull then '.' else symbol end
from
cells left join (
    select x as x2, y as y2, mine as mine2, count::text as symbol from totals
    union all
    select x as x2, y as y2, flag as mine2, 'X' as symbol from correct_flags
) on (cells.x = x2 and cells.y = y2 and cells.mine = mine2);

-- Create lines of output by grouping by `y`.
create view output as
select y, mine, string_agg(symbol, '' ORDER BY x) AS whole_row
from symbols
group by y, mine;
```

To view the output, we'll need to introduce some viewports, specifying rectangle and mine type:

```sql
-- Define overlapping viewports.
insert into viewport values (-10, 10, -10, 10, 0);
insert into viewport values (-5, 10, -5, 5, 1);
```

We can now peek at the output by selecting `whole_row` and ordering by `y`.
Let's first look at the `0` mine:

```
materialize=> select whole_row from output where mine = 0 order by y;
       whole_row
-----------------------
 .....................
 .....................
 .....................
 .....................
 .....................
 .....................
 .....................
 .....................
 .....................
 .....................
 ..........0..........
 .....................
 .....................
 .....................
 .....................
 .....................
 .....................
 .....................
 .....................
 .....................
 .....................
(21 rows)

materialize=>
```

Fascinating!

Let's do the `1` mine next:
```
materialize=> select whole_row from output where mine = 1 order by y;
    whole_row
------------------
 ................
 ................
 ................
 ................
 ................
 .....X..........
 ................
 ................
 ................
 ................
 ................
(11 rows)

materialize=>
```

Equally fascinating!
The same location, our correct guess that the `(0, 0)` mine has type `1`, is visible on both outputs!

Let's now ramp up the amount of visible information by making some informed guesses.

## Using SQL to play Minesweeper

You can play Minesweeper by repeatedly `INSERT`ing into `flags` and `tests`.

This probably gets tedious very quickly.
I could tell you; I haven't tried.

Instead, we can write SQL queries to produce modifications to these tables and insert them.

### Determining locations to test

We should be able to test any location that has no adjacent mines (of our type).
This is just a matter of looking at `totals` for counts of zero, and testing all neighbors.

```sql
-- We can test locations we know have no adjacent mines!
-- In fact, we can do this over and over until we stop inserting things.
create view should_test as
select distinct new_x as x, new_y as y, mine as test
from
    (select * from totals where count = 0),
    generate_series(x - 1, x + 1) as new_x,
    generate_series(y - 1, y + 1) as new_y
where x != new_x or y != new_y
except all
select * from distinct_tests;
```

If we peek at the contents of this view, we'll see locations that are safe to test.
```
materialize=> select * from should_test;
 x  | y  | test
----+----+------
  0 |  1 |    0
  0 | -1 |    0
  1 |  0 |    0
  1 |  1 |    0
  1 | -1 |    0
 -1 |  0 |    0
 -1 |  1 |    0
 -1 | -1 |    0
(8 rows)

materialize=>
```
As it turns out, all eight locations around the `(0, 0)` location are safe to test for mines of type `0`.
We could go and `INSERT` each of them, or we could use a SQL query to do that for us:

```
materialize=> insert into tests select * from should_test;
INSERT 0 8
```

This is now an exciting moment.
Let's look at the board again, for mines of type `0`.
```
materialize=> select whole_row from output where mine = 0 order by y;
       whole_row
-----------------------
 .....................
 .....................
 .....................
 .....................
 .....................
 .....................
 .....................
 .....................
 .....................
 .........100.........
 .........100.........
 .........111.........
 .....................
 .....................
 .....................
 .....................
 .....................
 .....................
 .....................
 .....................
 .....................
(21 rows)

materialize=>
```

We have more zeros!
You Minesweeper folks know what this means!
We .. should keep clicking.
We shouldn't *have* to keep clicking, but Materialize doesn't support `WITH RECURSIVE` yet (write your representative!)

```
materialize=> insert into tests select * from should_test;
INSERT 0 8
materialize=>
```

Eight more insertions!
This means that things changed again.

```
materialize=> select whole_row from output where mine = 0 order by y;
       whole_row
-----------------------
 .....................
 .....................
 .....................
 .....................
 .....................
 .....................
 .....................
 .....................
 .........2121........
 .........1000........
 .........1000........
 .........1111........
 .....................
 .....................
 .....................
 .....................
 .....................
 .....................
 .....................
 .....................
 .....................
(21 rows)

materialize=>
```

Let's do a hand-rolled recursive process, and keep doing this `INSERT INTO` command until we have no more changes.
```
materialize=> insert into tests select * from should_test;
INSERT 0 4
materialize=> insert into tests select * from should_test;
INSERT 0 3
materialize=> insert into tests select * from should_test;
INSERT 0 5
materialize=> insert into tests select * from should_test;
INSERT 0 6
materialize=> insert into tests select * from should_test;
INSERT 0 6
materialize=> insert into tests select * from should_test;
INSERT 0 3
materialize=> insert into tests select * from should_test;
INSERT 0 9
materialize=> insert into tests select * from should_test;
INSERT 0 8
materialize=> insert into tests select * from should_test;
INSERT 0 4
materialize=> insert into tests select * from should_test;
INSERT 0 3
materialize=> insert into tests select * from should_test;
INSERT 0 3
materialize=> insert into tests select * from should_test;
INSERT 0 6
materialize=> insert into tests select * from should_test;
INSERT 0 7
materialize=> insert into tests select * from should_test;
INSERT 0 7
materialize=> insert into tests select * from should_test;
INSERT 0 4
materialize=> insert into tests select * from should_test;
INSERT 0 4
materialize=> insert into tests select * from should_test;
INSERT 0 3
materialize=> insert into tests select * from should_test;
INSERT 0 0
materialize=>
```

You can imagine why `WITH RECURSIVE` can occasionally be popular.

Let's take a peek at the output again.
```
materialize=> select whole_row from output where mine = 0 order by y;
       whole_row
-----------------------
 .....................
 .....................
 .....................
 .....................
 .....................
 .....................
 .....................
 .....................
 .........21213.......
 .........100012......
 .........100001111...
 .........111110001...
 .............21011...
 .......222....101....
 ...2122101.1111012...
 ...200000111000001...
 ...210000000000012...
 ....1111001121112....
 .......1112..........
 .....................
 .....................
(21 rows)

materialize=>
```

That's pretty neat, isn't it!
We've built up a little island, and might now start thinking about where we can certainly place mines.

### Determining locations to flag

We can place flags using a variety of rules.
We'll use a simple one: if a grid cell with a count is short mines exactly the number of unmarked neighbors, all those neighbors must be mines.
This rule is great for filling in all of those corners and pockets you see up above.

```sql
-- We can flag locations when the count equals the number of untested neighbors.
create view could_flag as
select x, y, mine as flag
from totals
where totals.count > 0 and totals.count = 9 - (select count(*) from (
    select distinct *
    from
        generate_series(x - 1, x + 1) as probe_x,
        generate_series(y - 1, y + 1) as probe_y,
        correct_tests as tests
    where tests.x = probe_x and tests.y = probe_y and tests.test = mine
));

-- I DONT UNDERSTAND THIS ANY MORE! EXPLAIN!
create view should_flag as
select distinct * from (select probe_x as x, probe_y as y, flag
from
    could_flag,
    generate_series(x - 1, x + 1) as probe_x,
    generate_series(y - 1, y + 1) as probe_y
)
except all
select * from correct_tests
except all
select * from distinct_flags;
```

We can take a peek at the `should_flag` view, containing locations known to be mines.

```
materialize=> select * from should_flag;
 x  | y  | flag
----+----+------
  0 |  4 |    0
  1 |  8 |    0
  2 |  2 |    0
  3 |  3 |    0
  4 | -2 |    0
  5 | -1 |    0
  7 |  3 |    0
  7 |  7 |    0
 -7 |  7 |    0
 -5 |  3 |    0
 -4 |  3 |    0
 -4 |  8 |    0
(12 rows)

materialize=>
```

Let's just add them in, and check out the picture again.

```
materialize=> insert into flags select * from should_flag;
INSERT 0 12
materialize=> select whole_row from output where mine = 0 order by y;
       whole_row
-----------------------
 .....................
 .....................
 .....................
 .....................
 .....................
 .....................
 .....................
 .....................
 .........21213X......
 .........100012X.....
 .........100001111...
 .........111110001...
 ............X21011...
 .....XX222...X101X...
 ...2122101X1111012...
 ...200000111000001...
 ...210000000000012...
 ...X1111001121112X...
 ......X1112X.........
 .....................
 .....................
(21 rows)

materialize=>
```

Look at all those `X` things!

### Ready Player `1`

Having marked all these mines of type `0`, the boards for other mine types can be updated!
Remember, each of these mines mean that the grid cell is free of mines of other types.
Here is what that looks like for other players.

```
materialize=> select whole_row from output where mine = 1 order by y;
    whole_row
------------------
 ................
 ................
 ................
 .........3......
 ..........1.....
 .....X..........
 ................
 .......2........
 11......1...2...
 .....1..........
 ................
(11 rows)

materialize=>
```

Interesting!
We still see that mine there, but now have several other locations that have been explored.
No zeros though, so no automatic progress to make.

How about mines of type `2`?

```
materialize=> select whole_row from output where mine = 2 order by y;
 whole_row
-----------
(0 rows)

materialize=>
```

Ah, we need a viewport, don't we?
```
materialize=> insert into viewport values (-10, 10, -10, 10, 2);
INSERT 0 1
materialize=> insert into viewport values (-10, 10, -10, 10, 3);
INSERT 0 1
materialize=> insert into viewport values (-10, 10, -10, 10, 4);
INSERT 0 1
materialize=> insert into viewport values (-10, 10, -10, 10, 5);
INSERT 0 1
materialize=>
```

Now let's try that again for mines of type `2`.
```
materialize=> select whole_row from output where mine = 2 order by y;
       whole_row
-----------------------
 .....................
 .....................
 .....................
 .....................
 .....................
 .....................
 .....................
 .....................
 ..............0......
 ...............2.....
 ..........2..........
 .....................
 ............0........
 .....13......3...3...
 ..........2..........
 .....................
 .....................
 ...0.............0...
 ......1....1.........
 .....................
 .....................
(21 rows)

materialize=>
```

Several zeros!
Let's expand them out!

```
materialize=> insert into tests select * from should_test;
INSERT 0 86
materialize=>
```

Eek.
Eighty six additions.

```
materialize=> insert into tests select * from should_test;
INSERT 0 70
materialize=> insert into tests select * from should_test;
INSERT 0 42
materialize=> insert into tests select * from should_test;
INSERT 0 50
materialize=> insert into tests select * from should_test;
INSERT 0 39
materialize=> insert into tests select * from should_test;
INSERT 0 40
materialize=> insert into tests select * from should_test;
INSERT 0 47
materialize=> insert into tests select * from should_test;
INSERT 0 53
materialize=> insert into tests select * from should_test;
INSERT 0 36
materialize=> insert into tests select * from should_test;
INSERT 0 35
materialize=> insert into tests select * from should_test;
INSERT 0 33
materialize=> insert into tests select * from should_test;
INSERT 0 28
materialize=> insert into tests select * from should_test;
INSERT 0 20
materialize=> insert into tests select * from should_test;
INSERT 0 20
materialize=> insert into tests select * from should_test;
INSERT 0 28
materialize=> insert into tests select * from should_test;
INSERT 0 30
materialize=> insert into tests select * from should_test;
INSERT 0 30
materialize=> insert into tests select * from should_test;
INSERT 0 27
materialize=> insert into tests select * from should_test;
INSERT 0 17
materialize=> insert into tests select * from should_test;
INSERT 0 15
materialize=> insert into tests select * from should_test;
INSERT 0 3
materialize=> insert into tests select * from should_test;
INSERT 0 0
materialize=>
```

This is across all of the mine types, mind you.
Not all of them had zeros, though, so not all of them grew much.
```
materialize=> select test, count(*) from correct_tests group by test;
 test | count
------+-------
    0 |   101
    2 |   216
    3 |    24
    5 |   509
(4 rows)
```

Both `1` and `4` had no zeros, and so gained no tests.
Mines of type `5` are out of control, apparently.
Let's check.

```
materialize=> select whole_row from output where mine = 5 order by y;
       whole_row
-----------------------
 .....................
 2......11112111......
 124....10000001......
 001111.21011101......
 0000012.101.112......
 00000011101111.......
 00000000000001111....
 00000000001221001111.
 00122100113..1000001.
 112..2101....2000001.
 ......20112..1000123.
 12....20001..11111...
 01...310123.2...112..
 11...1001....2..201..
 .....1001222....102..
 .....1100001.222102..
 ......211001.100001..
 ...1....1002.200001..
 ......1.1113.310001..
 ..............1000123
 ............321000001
(21 rows)

materialize=>
```

That spills off the viewport in a few directions!